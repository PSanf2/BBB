These are Patrick Sanford's development notes.
This file contains information that will be of questionable value to 
anyone other than the author.

CONNECTING A DEVICE TO THE BBB

Connecting an I2C device to the BBB requires four pins.
The I2C device will need to have GND, VCC, SDA, and SCL pins connected 
to the BBB.

BBB					I2C Device
P9_01 GND		->	GND
P9_07 SYS_5V	->	VCC
P9_19 I2C2_SCL	->	SCL
P9_20 I2C2_SDA	->	SDA

NOTES ABOUT P9_07 vs P9_03
P9_03 DC_3.3V has been documented being used in the book on another device.
I'm not sure if P9_03 is limited, or goes through a power controller on the board.
Most Arduino breakout boards seem to need 5V. P9_07 provides that, and is regulated.
Don't try to power too many boards off the microcontroller. The SYS_5V rail
can only support 250mA. If I'm going to get insane with the number of boards
connected to the BBB then they should get their own power source.

Once you have the four rails established I should be able
to connect multiple devices to the bus. Each device on the
bus needs to have a unique address. The BBB has two I2C busses
available, but one of them isn't enabled by default. The bus i2c-0 shouldn't
be used for anything. I believe it's used for something involving HDMI.

WHEN CONNECTING A NEW DEVICE
sudo i2cdetect -l // To see which I2C busses are available. There's one that's not enabled by default.
sudo i2cdetect -y -r <i2c bus num> // To see which addresses are available. These roughly match to which devices are connected.
sudo i2cdump -y <i2c bus num> <i2c dev hex addr> // To dump all of the registers on the device.

CODING NOTES
Reading/Writing to/from an I2C device register isn't that difficult.
The main challenge is knowing what each register on a device is supposed to do.
I'm basically expanding off a class that does a good job of reading/writing
from a device. I'm writting wrappers that define functions for procedures that
need to be performed, and define vocabulary for abstraction.
Another challange may be in making sure I don't have collisions on the bus.
Once I have multiple devices communicating on the bus then I may need to
find a method to implement collision avoidance.

The LSM9DS0_Singleton branch contains code for the board that's running I2C_IO as a singleton.
This is being done to avoid collisions on the bus as various objects attempt to communicate with boards.
In order to avoid race conditions I'll have all of my objects utilize the I2C bus through a unified
interface. This will help to ensure there's a "gatekeeper" to ensure everybody takes turns. As long
as I don't try to get nuts with multi-threading on the I2C bus I should be alright. The singleton
verion of the I2C_IO class offer function calls that are simplified, more verbose, and provide greater
utility. When being called the member function provide a greater freedom to allow the programmer to
define what's getting put on the bus, and received, but they're expected to know what they're doing.

I eventually want to standardize the coding, and then update the main function for each breakout
board to support command line arguments, and return simple text results to the terminal. This will
allow a user another method of interaction with the library, and make it compatable with scripting,
and use by system calls. Command line arguments mean a user would be able to use one command to
perform a complex interaction with a breakout board, and get a immediate result. It means that the
system could also be used by programmers using other langages as long as they're able/willing to use
a system call. This will also make the system more able to be integrated with the OS. For example,
if I wanted to read a sensor input on a set schedule and log the result (or perform another action) I'd
be able to accomplish this with a bash script. When I start doing this I will also need to make sure
that the return function is returing the proper values for the OS to interpret. I also want to convert
all coded usage of numbers into hex. In some places bin is being used, others it's dec, and others it's
hex. I need to be using one numbering system throughout the code. I may wish to also consider adding
exceptions into the code. It'll make the error checking more consistant, and allow it to be handled in
a more dynamic manner. There's a standard exception library that will make most of this rather easy.
Another thing I may want to think about out switching to C++11. I'm currently running verison 4.6.3 of
g++. I may be able to use C++11 with the -std=c++0x option in the terminal. I may wish to just update
g++ on the system because support for C++11 on 4.6.3 doesn't appear to be optimal. Newer versions are
promising better support for the newer features. I should also go through the code, and find places
where default values may be defined for function parameters. Since each breakout board is unique there's
not much that can be done in terms of polymorphism or inheritance.

I also need to get proper make files set up. The system of using batch files to manage compiling
and linking the files into executables is just dumb.

For some reason the ADS1X15 boards don't want to work unless there's 
another board using the same bus, or the I2C pins are connected 
directly into the BBB with a short piece of wire. I believe this has 
something to do with pull-up/pull-down resistor usage. The datasheet 
for the boards has some diagrams wiring the microcontroller VCC line 
into each I2C line. I'm not about to attempt this with my BBB (and 
possibly damage it) when there's a stupid easy workaround. I'm not 
sure if this will become a concern at a later point. I worry that the 
I2C multiplexer I have may not pass a current onto the I2C bus that 
will keep the boards alive. If this is the case then I'll need to 
figure out what needs to be done. I may also need to consult with 
Adafruit customer support. Page one of the multiplexer datasheet says 
"external pullup resistors pull the bus up to the desired voltage 
level for each channel." This either means that pulling the I2C bus 
lines high isn't going to be a concern, or I'll need to add some 
capacitors and resistors to the mix. Page 12 of the datasheet clears 
it up. It explicitly states that the SDA/SCL lines must be connected 
to a positive supply through pullup resistors connected to the output 
stages of the device. This does not match up with the pictures on the 
Adafruit page. After checking additonal documentation it turns out 
that the chips can drive the bus, but cannot drive it high. This means 
that the chips are only going to be able to perform a limited number 
of functions without jumping each line to VCC through a resistor. YUP! 
I should be putting a resistor between each I2C bus line and VCC. 
It'll be between 1Kohm an 10Kohm on each of them. The values affect 
the communication speed. One source recommends 1k8 as giving the best 
value. Not having this set up on the bus lines is the reason the 
ADS1X15 boards won't work unless they're jacked directly into the BBB 
with a very short piece of wire. The resistance of the wire is causing 
what little signal to get through to get pulled down to 0v, and lost 
to heat. Fixed it! :-D I added a 1K resistor between VCC and each of 
the I2C lines and the chip started working. It's something that should 
be standard on my breadboard when working w/ I2C devices.
